"""\
nbb (ndim's branch builder) from @PACKAGE_NAME@ @PACKAGE_VERSION@
Build, install given branch of source code into a branch specific place
Copyright (C) 2007,2008 Hans Ulrich Niedermann

Usage: %(prog)s <to-be-determined>

Features:
 * supports git branches (TBD: git config)
 * supports bzr branches (requires useful branch nick, TBD: bzr config)
 * does out-of-source-tree builds (in-source-tree-builds unsupported)
 * direct support for automake/autoconf based build systems
 * TBD: supports execution of user commands in source, build, install dirs

TODO:
 * VCS config support ('git config', etc.)
 * Build system support: automake/autoconf, cmake
 * Design nice user interface. Requirements:
   * print top_srcdir, builddir, installdir
   * start subshell in top_srcdir, builddir, installdir
   * run 'autoreconf' type step
   * run 'configure' type step
   * run 'make' type step
   * run 'make install' type step
   * run custom (make) commands
 * Bash syntax completion for that user interface.
 * Man page or something similar.

Command line interface (TBD):

  Run default build commands:
  $ %(prog)s [general options] init [command specific options]
  $ %(prog)s [general options] configure [command specific options]
  $ %(prog)s [general options] build [command specific options]
  $ %(prog)s [general options] install [command specific options]

  Run cleanup commands:
  TBD

  Get/set config:
  $ %(prog)s [general options] config srcdir
  $ %(prog)s [general options] config builddir [<builddir>]
  $ %(prog)s [general options] config installdir [<installdir>]

  Start an interactive shell in either of the three directories:
  $ %(prog)s [general options] src-sh [command specific options]
  $ %(prog)s [general options] build-sh [command specific options]
  $ %(prog)s [general options] install-sh [command specific options]

  Run command in builddir:
  $ %(prog)s [general options] run <command> [<param>...]
  $ %(prog)s [general options] run [command specific options... <-->] <cmd>...

  (Not sure about these)
  Run a non-interactive shell command in either of the three directories:
  $ %(prog)s [general options] src-sh [command specific options] <command>...
  $ %(prog)s [general options] build-sh [command specific options] <command>...
  $ %(prog)s [general options] install-sh [command specific options] <cmd...>

Global options:

  -h --help          Print this help text
  -V --version       Print program version number

  -n --dry-run       Do not actually execute any commands

  -b --build-system  Force buildsystem detection (%(buildsystems)s)
  -v --vcs           Force VCS detection (%(vcssystems)s)

"""

import sys
import os
import getopt

import subprocess
import urlparse


# Used to make sure nbb_lib and nbb fit together
version = "@PACKAGE_VERSION@"


########################################################################
# Utility functions
########################################################################


def prog_stdout(call_list):
    """Run program and return stdout (similar to shell backticks)"""
    p = subprocess.Popen(call_list,
                         stdout=subprocess.PIPE,
                         stderr=subprocess.PIPE)
    stdout, stderr = p.communicate(input=None)
    return stdout.strip()


class ProgramRunError(Exception):
    """A program run returns a retcode != 0"""
    def __init__(self, call_list, retcode, cwd=None):
        self.call_list = call_list
        self.retcode = retcode
        if cwd:
            self.cwd = cwd
        else:
            self.cwd = os.getcwd()
    def __str__(self):
        return ("Error running program (%s, retcode=%d, cwd=%s)"
                % (repr(self.call_list),
                   self.retcode,
                   repr(self.cwd)))


def prog_run(call_list):
    """Run program showing its output. Raise exception if retcode != 0."""
    print "RUN:", call_list
    print "  in", os.getcwd()
    return None
    p = subprocess.Popen(call_list)
    stdout, stderr = p.communicate(input=None)
    if p.returncode != 0:
        raise ProgramRunError(call_list, p.returncode, os.getcwd())
    return p.returncode


class AbstractConfig(object):
    """Return static config until we implement real config reading"""
    def __init__(self, srcdir, nick):
        self.srcdir = srcdir
        self.nick = nick
    def srcdir(self):
        return os.path.join(self.srcdir)
    def builddir(self):
        return os.path.join(self.srcdir, "_build", self.nick)
    def installdir(self):
        return os.path.join(self.srcdir, "_install", self.nick)


########################################################################
# VCS Source Tree plugin system
########################################################################
# Plugin architecture (metaclass tricks) by Marty Alchin from
# http://gulopine.gamemusic.org/2008/jan/10/simple-plugin-framework/
########################################################################

class NotAVCSourceTree(Exception):
    pass

class VCSourceTreeMeta(type):
    def __init__(cls, name, bases, attrs):
        if not hasattr(cls, 'plugins'):
            # This branch only executes when processing the mount point itself.
            # So, since this is a new plugin type, not an implementation, this
            # class shouldn't be registered as a plugin. Instead, it sets up a
            # list where plugins can be registered later.
            cls.plugins = []
        else:
            # This must be a plugin implementation, which should be registered.
            # Simply appending it to the list is all that's needed to keep
            # track of it later.
            cls.plugins.append(cls)


class VCSourceTree(object):
    """
    Mount point for plugins which refer to actions that can be performed.

    Plugins implementing this reference should provide the following
    interface:

    vcs_name  attribute
        The text to be displayed, describing the version control system
    __init__  function
        Must raise NotAVCSourceTree() if it is not a VCS source tree
    """
    __metaclass__ = VCSourceTreeMeta

    def detect(cls, srcdir):
        """Detect VCS tree type and return object representing it"""
        if len(VCSourceTree.plugins) < 1:
            raise "No VC source tree classes registered"
        def check_class(klass):
            try:
                t = klass(srcdir)
                return t
            except NotAVCSourceTree:
                return None
        matches = filter(lambda x:x, map(check_class, VCSourceTree.plugins))
        if len(matches) > 1:
            raise ("More than one source tree type detected for '%s': %s"
                   % (srcdir, ", ".join(map(lambda x:str(x), matches))))
        elif len(matches) < 1:
            raise "Source tree type for '%s' not detected" % (srcdir,)
        return matches[0]
    detect = classmethod(detect)

    def get_config(self):
        """Get configuration object which determines builddir etc"""
        return AbstractConfig(self.tree_root(), self.branch_name())

    def tree_root(self):
        """Get absolute path to source tree root"""
        raise NotImplementedError()

    def branch_name(self):
        """Return name identifying the branch"""
        raise NotImplementedError()

    def __str__(self):
        return "VCS-Source-Tree(%s, %s, %s)" % (self.vcs_name,
                                                repr(self.tree_root()),
                                                repr(self.branch_name()))


########################################################################
# VCS Source Tree plugins
########################################################################

class GitSourceTree(VCSourceTree):

    vcs_name = 'git'

    def __init__(self, srcdir):
        os.chdir(srcdir)
        if "true" != prog_stdout(["git", "rev-parse",
                                  "--is-inside-work-tree"]):
            raise NotAVCSourceTree()
        os.chdir(prog_stdout(["git", "rev-parse", "--show-cdup"]))
        self.__tree_root = os.getcwd()

    def tree_root(self):
        return self.__tree_root

    def branch_name(self):
        bname = prog_stdout(["git", "symbolic-ref", "HEAD"])
        refs,heads,branch = bname.split('/')
        assert(refs=='refs' and heads=='heads')
        return branch


class BzrSourceTree(VCSourceTree):

    vcs_name = 'bzr'

    def __init__(self, srcdir):
        try:
            import bzrlib.workingtree
            wt,b = bzrlib.workingtree.WorkingTree.open_containing(srcdir)
        except bzrlib.errors.NotBranchError:
            raise NotAVCSourceTree()
        except ImportError:
            raise NotAVCSourceTree()
        self.wt = wt
        #print "wt:", wt
        #print "wt:", dir(wt)
        #print "wt.branch:", wt.branch
        #print "wt.branch:", dir(wt.branch)
        #print "wt.branch.nick:", wt.branch.nick
        #print "wt.branch.abspath:", wt.branch.abspath
        #print "wt.branch.base:", wt.branch.base
        #print "wt.branch.basis_tree:", wt.branch.basis_tree()

    def tree_root(self):
        proto,host,path,some,thing = urlparse.urlsplit(self.wt.branch.base)
        assert(proto == "file" and host == "")
        assert(some == "" and thing == "")
        return path

    def branch_name(self):
        return self.wt.branch.nick


########################################################################
# Buildsystem Source Tree plugin system
########################################################################
# Plugin architecture (metaclass tricks) by Marty Alchin from
# http://gulopine.gamemusic.org/2008/jan/10/simple-plugin-framework/
########################################################################

class NotABSSourceTree(Exception): pass

class BSSourceTreeMeta(type):
    def __init__(cls, name, bases, attrs):
        if not hasattr(cls, 'plugins'):
            cls.plugins = []
        else:
            cls.plugins.append(cls)


class BSSourceTree(object):
    __metaclass__ = BSSourceTreeMeta

    def detect(cls, vcs_tree):
        """Find BS tree type and return it"""
        if len(BSSourceTree.plugins) < 1:
            raise "No BS source tree classes registered"
        def check_class(klass):
            try:
                t = klass(vcs_tree)
                return t
            except NotABSSourceTree:
                return None
        matches = filter(lambda x:x, map(check_class, BSSourceTree.plugins))
        if len(matches) > 1:
            raise ("More than one source tree type detected for '%s': %s"
                   % (vcs_tree, ", ".join(map(lambda x:str(x), matches))))
        elif len(matches) < 1:
            raise "Source tree type for '%s' not detected" % (vcs_tree,)
        return matches[0]
    detect = classmethod(detect)

    def __str__(self):
        return "BS-Source-Tree(%s, %s)" % (self.bs_name,
                                           repr(self.tree_root()))

    # Abstract methods
    def tree_root(self): raise NotImplementedError()
    def init(self): raise NotImplementedError()
    def configure(self): raise NotImplementedError()
    def build(self): raise NotImplementedError()
    def install(self): raise NotImplementedError()


class AutomakeSourceTree(BSSourceTree):
    bs_name = 'automake'
    def __init__(self, vcs_tree):
        srcdir = vcs_tree.tree_root()
        self.config = vcs_tree.get_config()
        flag = False
        for f in [ os.path.join(srcdir, 'configure.ac'),
                   os.path.join(srcdir, 'configure.in'),
                   ]:
            if os.path.exists(f):
                flag = True
                break
        if not flag:
            raise NotABSSourceTree()
        self.srcdir = srcdir

    def tree_root(self):
        return self.srcdir

    def init(self):
        """'autoreconf'"""
        prog_run(["autoreconf", "-v", "-i", "-s", self.srcdir])

    def configure(self):
        """'configure --prefix'"""
        builddir = self.config.builddir()
        if not os.path.exists(builddir): os.makedirs(builddir)
        os.chdir(builddir)
        prog_run(["%s/configure" % self.srcdir,
                  "--prefix=%s" % self.config.installdir()
                  ])

    def build(self):
        """'make'"""
        os.chdir(self.config.builddir())
        prog_run(["make", ])

    def install(self):
        """'make install'"""
        os.chdir(self.config.builddir())
        prog_run(["make", "install", "INSTALL=/usr/bin/install -p"])


########################################################################
# Main program
########################################################################

class NBB(object):
    def __init__(self, srcdir=None):
        if srcdir is None:
            srcdir = os.getcwd()
        absdir = os.path.abspath(srcdir)
        self.vcs_sourcetree = VCSourceTree.detect(absdir)
        print str(self.vcs_sourcetree)
        #print "sourcetree:", dir(self.sourcetree)
        self.bs_sourcetree = BSSourceTree.detect(self.vcs_sourcetree)
        print str(self.bs_sourcetree)
        try:
            self.bs_sourcetree.init()
            self.bs_sourcetree.configure()
            self.bs_sourcetree.build()
            self.bs_sourcetree.install()
        except ProgramRunError, e:
            print "Fatal:", e
            print "Program aborted."


def main(argv):

    prog = argv[0]
    idx = prog.rfind('/')
    if idx >= 0:
        prog = prog[idx+1:]

#    print """\
#WARNING: %(prog)s is very much a work in progress.
#         Large parts of %(prog)s are not implemented yet.
#""" % locals()

    # FIXME: Generate from plugin systems.
    buildsystems = ', '.join(['automake', ])
    vcssystems = ', '.join(['bzr', 'git', ])

    optlist, args = getopt.getopt(argv[1:], 'hV', ['help', 'version'])
    for opt, arg in optlist:
        if opt in ('-h', '--help'):
            print __doc__ % locals()
            return
        elif opt in ('-V', '--version'):
            print "%(prog)s (@PACKAGE_NAME@) @PACKAGE_VERSION@" % locals()
            return
        else:
            raise NotImplementedError()

    if len(args) == 0:
        nbb = NBB()
    elif len(args) == 1:
        nbb = NBB(args[0])
    else:
        raise NotImplementedError()


if __name__ == '__main__':
    raise "This is not a library"

# vim: syntax=python
# Local Variables:
# mode: python
# End:
