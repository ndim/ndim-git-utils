import sys
import os
import getopt

from subprocess import Popen
import subprocess

import urlparse


########################################################################
# Utility functions
########################################################################


def prog_stdout(call_list):
    p = Popen(call_list, stdout=subprocess.PIPE)
    stdout, stderr = p.communicate()
    return stdout.strip()


########################################################################
# VCS Source Tree plugin system
########################################################################
# Plugin architecture (metaclass tricks) by Marty Alchin from
# http://gulopine.gamemusic.org/2008/jan/10/simple-plugin-framework/
########################################################################

class NotASourceTree(Exception):
    pass

class VCSourceTreeMeta(type):
    vc_srctree_classes = []
    def __init__(cls, name, bases, attrs):
        if not hasattr(cls, 'plugins'):
            # This branch only executes when processing the mount point itself.
            # So, since this is a new plugin type, not an implementation, this
            # class shouldn't be registered as a plugin. Instead, it sets up a
            # list where plugins can be registered later.
            cls.plugins = []
        else:
            # This must be a plugin implementation, which should be registered.
            # Simply appending it to the list is all that's needed to keep
            # track of it later.
            cls.plugins.append(cls)


class VCSourceTree(object):
    """
    Mount point for plugins which refer to actions that can be performed.

    Plugins implementing this reference should provide the following
    interface:

    vcs_name  attribute
        The text to be displayed, describing the version control system
    __init__  function
        Must raise NotASourceTree() if it is not a VCS source tree
    """
    __metaclass__ = VCSourceTreeMeta

    def detect(cls, srcdir):
        """Find VCS tree type and return it"""
        def check_class(klass):
            try:
                t = klass(srcdir)
                #print "t:", t
                return t
            except NotASourceTree:
                return None
        if len(VCSourceTree.plugins) < 1:
            raise "No VC source tree classes registered"
        t_matches = [check_class(k) for k in VCSourceTree.plugins]
        matches = [x for x in t_matches if x]
        if len(matches) > 1:
            raise ("More than one source tree type detected for '%s': %s"
                   % (srcdir, ", ".join(map(lambda x:str(x), matches))))
        elif len(matches) < 1:
            raise "Source tree type for '%s' not detected" % (srcdir,)
        print "returning match:", matches[0]
        return matches[0]
    detect = classmethod(detect)

    def tree_root(self):
        raise NotImplementedError()

    def branch_name(self):
        """Return name identifying the branch"""
        raise NotImplementedError()

    def __str__(self):
        return "VCS-Source-Tree(%s, %s, %s)" % (self.vcs_name,
                                                repr(self.tree_root()),
                                                repr(self.branch_name()))


########################################################################
# VCS Source Tree plugins
########################################################################

class GitSourceTree(VCSourceTree):

    vcs_name = 'git'

    def __init__(self, srcdir):
        os.chdir(srcdir)
        if "true" != prog_stdout(["git", "rev-parse",
                                  "--is-inside-work-tree"]):
            raise NotASourceTree()
        self.__tree_root = srcdir

    def tree_root(self):
        return self.__tree_root

    def branch_name(self):
        bname = prog_stdout(["git", "symbolic-ref", "HEAD"])
        refs,heads,branch = bname.split('/')
        assert(refs=='refs' and heads=='heads')
        return branch


class BzrSourceTree(VCSourceTree):

    vcs_name = 'bzr'

    def __init__(self, srcdir):
        try:
            import bzrlib.workingtree
            wt,b = bzrlib.workingtree.WorkingTree.open_containing(srcdir)
        except bzrlib.errors.NotBranchError:
            raise NotASourceTree()
        except ImportError:
            raise NotASourceTree()
        self.wt = wt
        #print "wt:", wt
        #print "wt:", dir(wt)
        #print "wt.branch:", wt.branch
        #print "wt.branch:", dir(wt.branch)
        #print "wt.branch.nick:", wt.branch.nick
        #print "wt.branch.abspath:", wt.branch.abspath
        #print "wt.branch.base:", wt.branch.base
        #print "wt.branch.basis_tree:", wt.branch.basis_tree()

    def tree_root(self):
        proto,host,path,some,thing = urlparse.urlsplit(self.wt.branch.base)
        assert(proto == "file" and host == "")
        assert(some == "" and thing == "")
        return path

    def branch_name(self):
        return self.wt.branch.nick


########################################################################
# Main program
########################################################################

class NBB(object):
    def __init__(self, srcdir=None):
        if srcdir is None:
            srcdir = os.getcwd()
        self.sourcetree = VCSourceTree.detect(os.path.abspath(srcdir))
        print "sourcetree: %s" % str(self.sourcetree)
        #print "sourcetree:", dir(self.sourcetree)


def main(argv):
    prog = argv[0]
    idx = prog.rfind('/')
    if idx >= 0:
        prog = prog[idx+1:]
    optlist, args = getopt.getopt(argv[1:], 'hV', [
            'help', 'version'])
    for opt, arg in optlist:
        if opt in ('-h', '--help'):
            print "Usage: %(prog)s" % locals()
            return
        elif opt in ('-V', '--version'):
            print "%(prog)s (@PACKAGE_NAME@) @PACKAGE_VERSION@"
            return
        else:
            raise NotImplementedError()
    if len(args) == 0:
        nbb = NBB()
    elif len(args) == 1:
        nbb = NBB(args[0])
    else:
        raise NotImplementedError()


if __name__ == '__main__':
    raise "This is not a library"

# Local Variables:
# mode: python
# End:
