import sys
import os
from subprocess import Popen
import subprocess


########################################################################
# Utility functions
########################################################################


def prog_stdout(call_list):
    p = Popen(call_list, stdout=subprocess.PIPE)
    stdout, stderr = p.communicate()
    return stdout.strip()


########################################################################
# VCS Source Tree plugin system
########################################################################

class NotASourceTree(Exception):
    pass

class VCSourceTreeMeta(type):
    vc_srctree_classes = []
    def __init__(cls, name, bases, attrs):
        if not hasattr(cls, 'plugins'):
            # This branch only executes when processing the mount point itself.
            # So, since this is a new plugin type, not an implementation, this
            # class shouldn't be registered as a plugin. Instead, it sets up a
            # list where plugins can be registered later.
            cls.plugins = []
        else:
            # This must be a plugin implementation, which should be registered.
            # Simply appending it to the list is all that's needed to keep
            # track of it later.
            cls.plugins.append(cls)


class VCSourceTree(object):
    """
    Mount point for plugins which refer to actions that can be performed.

    Plugins implementing this reference should provide the following
    interface:

    vcs_name  attribute
        The text to be displayed, describing the version control system
    __init__  function
        Must raise NotASourceTree() if it is not a VCS source tree
    """
    __metaclass__ = VCSourceTreeMeta

    def detect(cls, srcdir):
        def check_class(klass):
            try:
                return klass(srcdir)
            except NotASourceTree:
                return None
        if len(VCSourceTree.plugins) < 1:
            raise "No VC source tree classes registered"
        matches = filter(check_class, VCSourceTree.plugins)
        if len(matches) > 1:
            raise ("More than one source tree type detected for '%s'"
                   % (srcdir,))
        elif len(matches) < 1:
            raise "Source tree type for '%s' not detected" % (srcdir,)
        return matches[0]
    detect = classmethod(detect)


########################################################################
# VCS Source Tree plugins
########################################################################

class GitSourceTree(VCSourceTree):

    vcs_name = 'git'

    def __init__(self, srcdir):
        if "true" != prog_stdout(["git", "rev-parse",
                                  "--is-inside-work-tree"]):
            raise NotASourceTree()
        self.top_srcdir = os.path.join(srcdir, '.') # FIXME)

    def __str__(self):
        return "%s(%s)" % (self.__class__.__name__, self.top_srcdir)


class BzrSourceTree(VCSourceTree):

    vcs_name = 'bzr'

    def __init__(self, srcdir):
        try:
            import bzrlib.workingtree
            wt,b = bzrlib.workingtree.WorkingTree.open_containing(".")
        except bzrlib.errors.NotBranchError:
            raise NotASourceTree()
        except ImportError:
            raise NotASourceTree()
        self.wt = wt
        print "wt:", wt
        print "b:", b
        print "wt:", dir(wt)
        print "b:", dir(b)

    def __str__(self):
        return "%s(%s)" % (self.__class__.__name__, self.top_srcdir)


########################################################################
# Main program
########################################################################

class NBB(object):
    def __init__(self):
        srcdir = os.getcwd()
        self.sourcetree = VCSourceTree.detect(srcdir)
        print "sourcetree: %s" % self.sourcetree
        print "sourcetree:", dir(self.sourcetree)


def main(argv):
    prog = argv[0]
    idx = prog.rfind('/')
    if idx >= 0:
        prog = prog[idx+1:]
    for arg in argv[1:]:
        if arg in ('-h', '--help'):
            print "Usage: %(prog)s" % locals()
            return
        elif arg in ('-V', '--version'):
            print "%(prog)s (@PACKAGE_NAME@) @PACKAGE_VERSION@"
            return
        else:
            pass
    nbb = NBB()


if __name__ == '__main__':
    raise "This is not a library"

# Local Variables:
# mode: python
# End:
